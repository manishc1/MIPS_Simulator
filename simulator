#! /usr/bin/python

"""
Entry point for the simulation.
"""

from collections import deque
from computer import *
from data_cache import *
from instruction_container import *
from instruction_cache import *
from scanner import *

import operator
import sys


output = []


def write_back_organize(new_instruction_containers, exe_instruction_containers):
    priority = {}
    count = MAX

    for i in range(len(exe_instruction_containers)):
        exe = exe_instruction_containers.pop()

        functional_unit = exe.instruction.determine_exec_functional_unit()

        is_fp_flag = False
        for fu in FP_UNITS:
            if (functional_unit == fu):
                if (FP_CONFIG[fu]['PIPELINED']):
                    priority[exe] = count + FP_CONFIG[fu]['CYCLES']
                else:
                    priority[exe] = count + FP_CONFIG[fu]['CYCLES'] + MAX
                is_fp_flag = True
                break
        if (not is_fp_flag):
            priority[exe] = count

        count -= 1

    sorted_x = sorted(priority.iteritems(), key=operator.itemgetter(1), reverse=True)
    for element in sorted_x:
        new_instruction_containers.appendleft(element[0])

    return new_instruction_containers


def organize(old_instruction_containers):
    """
    Organize instructions in WB - EX - ID - IF manner.
    """
    new_instruction_containers = deque([])

    for i in range(len(old_instruction_containers)):
        ic = old_instruction_containers.pop()
        if ic.current_pipeline_stage.name == 'WB':
            new_instruction_containers.appendleft(ic)
        else:
            old_instruction_containers.appendleft(ic)

    exe_instruction_containers = deque([])
    for i in range(len(old_instruction_containers)):
        ic = old_instruction_containers.pop()
        if ic.current_pipeline_stage.name == 'EX':
            exe_instruction_containers.appendleft(ic)
        else:
            old_instruction_containers.appendleft(ic)

    new_instruction_containers = write_back_organize(new_instruction_containers, exe_instruction_containers)

    for i in range(len(old_instruction_containers)):
        ic = old_instruction_containers.pop()
        if ic.current_pipeline_stage.name == 'ID':
            new_instruction_containers.appendleft(ic)
        else:
            old_instruction_containers.appendleft(ic)

    for i in range(len(old_instruction_containers)):
        ic = old_instruction_containers.pop()
        if ic.current_pipeline_stage.name == 'IF':
            new_instruction_containers.appendleft(ic)
        else:
            old_instruction_containers.appendleft(ic)

    return new_instruction_containers


def print_output():
    """
    Print the final output.
    """
    res = sorted(output, key=lambda x: x.cycles[STAGES[0]])
    res[len(res) - 1].cycles[STAGES[1]] = 0

    op = ''
    op += '-' * 94 + '\n'
    op += '\tInstruction\t\tFT\tID\tEX\tWB\tRAW\tWAR\tWAW\tStruct\n'
    op += '-' * 94 + '\n'

    for i in range(len(res)):
        found_label = False
        for label, address in LABEL.items():
            if res[i].instruction.location == address:
                found_label = True
                op += label + ':\t'
        if not found_label:
            op += '\t'
        op += str(res[i]) + '\n'

    op += '-' * 94 + '\n'
    op += '\nTotal number of access requests for instruction cache: ' + str(Instruction_Cache.requests)
    op += '\nNumber of instruction cache hits: ' + str(Instruction_Cache.hits)
    op += '\nTotal number of access requests for data cache: ' + str(Data_Cache.requests)
    op += '\nNumber of data cache hits: ' + str(Data_Cache.hits)

    #file = open(filename, 'w')
    #file.write(output)
    #file.close()
    print op


def init_cache():
    """
    Initialize instruction and data cache.
    """
    Instruction_Cache()
    Data_Cache()


def simulate():
    """
    Simulate the execution of the instructions.
    """
    init_cache()

    clock_cycle = 1
    REGISTERS['PC'] = 1
    
    active_instruction_containers = deque([Instruction_Container(INSTRUCTIONS[0], clock_cycle)])

    while (len(active_instruction_containers) > 0):
        active_instruction_containers = organize(active_instruction_containers)
        future_instruction_containers = deque([])

        while (len(active_instruction_containers) > 0):
            ic = active_instruction_containers.pop()
            if (ic.keep_executing()):                
                future_instruction_containers.appendleft(ic)
            else:
                output.append(ic.output)

        active_instruction_containers = future_instruction_containers

        clock_cycle += 1

        if ((REGISTERS['PC'] < len(INSTRUCTIONS)) and
            (STAGE_FLAG['IF'] == AVAILABLE)):
            active_instruction_containers.appendleft(Instruction_Container(INSTRUCTIONS[REGISTERS['PC']], clock_cycle))
            REGISTERS['PC'] += 1

    print_output()


def main(instFile, dataFile, regFile, configFile, resultFile):
    """
    Scan the files and issue simulation.
    """
    try:
        Scanner.scan_instructions(instFile)
        Scanner.scan_data(dataFile)
        Scanner.scan_registers(regFile)
        Scanner.scan_configuration(configFile)
    except Exception as e:
        print 'Scanning Error: ' + str(e)
        exit()

    simulate()

        
if __name__ == "__main__":
    """
    Entry point to the simulator.
    """
    nArgs = len(sys.argv)
    args = sys.argv
    if (nArgs != 6):
        print "Usage: simulator inst.txt data.txt reg.txt config.txt result.txt"
        exit()
    main(args[1], args[2], args[3], args[4], args[5])
